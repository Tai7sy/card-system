<?php
 namespace League\Flysystem\Adapter; use ErrorException; use League\Flysystem\Adapter\Polyfill\StreamedCopyTrait; use League\Flysystem\AdapterInterface; use League\Flysystem\Config; use League\Flysystem\Util; use League\Flysystem\Util\MimeType; use RuntimeException; class Ftp extends AbstractFtpAdapter { use StreamedCopyTrait; protected $transferMode = FTP_BINARY; protected $ignorePassiveAddress = null; protected $recurseManually = false; protected $utf8 = false; protected $configurable = [ 'host', 'port', 'username', 'password', 'ssl', 'timeout', 'root', 'permPrivate', 'permPublic', 'passive', 'transferMode', 'systemType', 'ignorePassiveAddress', 'recurseManually', 'utf8', ]; protected $isPureFtpd; public function setTransferMode($mode) { $this->transferMode = $mode; return $this; } public function setSsl($ssl) { $this->ssl = (bool) $ssl; return $this; } public function setPassive($passive = true) { $this->passive = $passive; } public function setIgnorePassiveAddress($ignorePassiveAddress) { $this->ignorePassiveAddress = $ignorePassiveAddress; } public function setRecurseManually($recurseManually) { $this->recurseManually = $recurseManually; } public function setUtf8($utf8) { $this->utf8 = (bool) $utf8; } public function connect() { if ($this->ssl) { $this->connection = ftp_ssl_connect($this->getHost(), $this->getPort(), $this->getTimeout()); } else { $this->connection = ftp_connect($this->getHost(), $this->getPort(), $this->getTimeout()); } if ( ! $this->connection) { throw new RuntimeException('Could not connect to host: ' . $this->getHost() . ', port:' . $this->getPort()); } $this->login(); $this->setUtf8Mode(); $this->setConnectionPassiveMode(); $this->setConnectionRoot(); $this->isPureFtpd = $this->isPureFtpdServer(); } protected function setUtf8Mode() { if ($this->utf8) { $response = ftp_raw($this->connection, "OPTS UTF8 ON"); if (substr($response[0], 0, 3) !== '200') { throw new RuntimeException( 'Could not set UTF-8 mode for connection: ' . $this->getHost() . '::' . $this->getPort() ); } } } protected function setConnectionPassiveMode() { if (is_bool($this->ignorePassiveAddress) && defined('FTP_USEPASVADDRESS')) { ftp_set_option($this->connection, FTP_USEPASVADDRESS, ! $this->ignorePassiveAddress); } if ( ! ftp_pasv($this->connection, $this->passive)) { throw new RuntimeException( 'Could not set passive mode for connection: ' . $this->getHost() . '::' . $this->getPort() ); } } protected function setConnectionRoot() { $root = $this->getRoot(); $connection = $this->connection; if ($root && ! ftp_chdir($connection, $root)) { throw new RuntimeException('Root is invalid or does not exist: ' . $this->getRoot()); } $this->root = ftp_pwd($connection); } protected function login() { set_error_handler(function () {}); $isLoggedIn = ftp_login( $this->connection, $this->getUsername(), $this->getPassword() ); restore_error_handler(); if ( ! $isLoggedIn) { $this->disconnect(); throw new RuntimeException( 'Could not login with connection: ' . $this->getHost() . '::' . $this->getPort( ) . ', username: ' . $this->getUsername() ); } } public function disconnect() { if (is_resource($this->connection)) { ftp_close($this->connection); } $this->connection = null; } public function write($path, $contents, Config $config) { $stream = fopen('php://temp', 'w+b'); fwrite($stream, $contents); rewind($stream); $result = $this->writeStream($path, $stream, $config); fclose($stream); if ($result === false) { return false; } $result['contents'] = $contents; $result['mimetype'] = Util::guessMimeType($path, $contents); return $result; } public function writeStream($path, $resource, Config $config) { $this->ensureDirectory(Util::dirname($path)); if ( ! ftp_fput($this->getConnection(), $path, $resource, $this->transferMode)) { return false; } if ($visibility = $config->get('visibility')) { $this->setVisibility($path, $visibility); } $type = 'file'; return compact('type', 'path', 'visibility'); } public function update($path, $contents, Config $config) { return $this->write($path, $contents, $config); } public function updateStream($path, $resource, Config $config) { return $this->writeStream($path, $resource, $config); } public function rename($path, $newpath) { return ftp_rename($this->getConnection(), $path, $newpath); } public function delete($path) { return ftp_delete($this->getConnection(), $path); } public function deleteDir($dirname) { $connection = $this->getConnection(); $contents = array_reverse($this->listDirectoryContents($dirname, false)); foreach ($contents as $object) { if ($object['type'] === 'file') { if ( ! ftp_delete($connection, $object['path'])) { return false; } } elseif ( ! $this->deleteDir($object['path'])) { return false; } } return ftp_rmdir($connection, $dirname); } public function createDir($dirname, Config $config) { $connection = $this->getConnection(); $directories = explode('/', $dirname); foreach ($directories as $directory) { if (false === $this->createActualDirectory($directory, $connection)) { $this->setConnectionRoot(); return false; } ftp_chdir($connection, $directory); } $this->setConnectionRoot(); return ['type' => 'dir', 'path' => $dirname]; } protected function createActualDirectory($directory, $connection) { $listing = ftp_nlist($connection, '.') ?: []; foreach ($listing as $key => $item) { if (preg_match('~^\./.*~', $item)) { $listing[$key] = substr($item, 2); } } if (in_array($directory, $listing, true)) { return true; } return (boolean) ftp_mkdir($connection, $directory); } public function getMetadata($path) { $connection = $this->getConnection(); if ($path === '') { return ['type' => 'dir', 'path' => '']; } if (@ftp_chdir($connection, $path) === true) { $this->setConnectionRoot(); return ['type' => 'dir', 'path' => $path]; } $listing = $this->ftpRawlist('-A', str_replace('*', '\\*', $path)); if (empty($listing) || in_array('total 0', $listing, true)) { return false; } if (preg_match('/.* not found/', $listing[0])) { return false; } if (preg_match('/^total [0-9]*$/', $listing[0])) { array_shift($listing); } return $this->normalizeObject($listing[0], ''); } public function getMimetype($path) { if ( ! $metadata = $this->getMetadata($path)) { return false; } $metadata['mimetype'] = MimeType::detectByFilename($path); return $metadata; } public function getTimestamp($path) { $timestamp = ftp_mdtm($this->getConnection(), $path); return ($timestamp !== -1) ? ['path' => $path, 'timestamp' => $timestamp] : false; } public function read($path) { if ( ! $object = $this->readStream($path)) { return false; } $object['contents'] = stream_get_contents($object['stream']); fclose($object['stream']); unset($object['stream']); return $object; } public function readStream($path) { $stream = fopen('php://temp', 'w+b'); $result = ftp_fget($this->getConnection(), $stream, $path, $this->transferMode); rewind($stream); if ( ! $result) { fclose($stream); return false; } return ['type' => 'file', 'path' => $path, 'stream' => $stream]; } public function setVisibility($path, $visibility) { $mode = $visibility === AdapterInterface::VISIBILITY_PUBLIC ? $this->getPermPublic() : $this->getPermPrivate(); if ( ! ftp_chmod($this->getConnection(), $mode, $path)) { return false; } return compact('path', 'visibility'); } protected function listDirectoryContents($directory, $recursive = true) { $directory = str_replace('*', '\\*', $directory); if ($recursive && $this->recurseManually) { return $this->listDirectoryContentsRecursive($directory); } $options = $recursive ? '-alnR' : '-aln'; $listing = $this->ftpRawlist($options, $directory); return $listing ? $this->normalizeListing($listing, $directory) : []; } protected function listDirectoryContentsRecursive($directory) { $listing = $this->normalizeListing($this->ftpRawlist('-aln', $directory) ?: [], $directory); $output = []; foreach ($listing as $item) { $output[] = $item; if ($item['type'] !== 'dir') continue; $output = array_merge($output, $this->listDirectoryContentsRecursive($item['path'])); } return $output; } public function isConnected() { try { return is_resource($this->connection) && ftp_rawlist($this->connection, $this->getRoot()) !== false; } catch (ErrorException $e) { if (strpos($e->getMessage(), 'ftp_rawlist') === false) { throw $e; } return false; } } protected function isPureFtpdServer() { $response = ftp_raw($this->connection, 'HELP'); return stripos(implode(' ', $response), 'Pure-FTPd') !== false; } protected function ftpRawlist($options, $path) { $connection = $this->getConnection(); if ($this->isPureFtpd) { $path = str_replace(' ', '\ ', $path); } return ftp_rawlist($connection, $options . ' ' . $path); } } 