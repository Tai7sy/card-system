<?php
 class Swift_StreamFilters_ByteArrayReplacementFilter implements Swift_StreamFilter { private $replace; private $index; private $tree = []; private $treeMaxLen = 0; private $repSize; public function __construct($search, $replace) { $this->index = []; $this->tree = []; $this->replace = []; $this->repSize = []; $tree = null; $i = null; $last_size = $size = 0; foreach ($search as $i => $search_element) { if (null !== $tree) { $tree[-1] = min(count($replace) - 1, $i - 1); $tree[-2] = $last_size; } $tree = &$this->tree; if (is_array($search_element)) { foreach ($search_element as $k => $char) { $this->index[$char] = true; if (!isset($tree[$char])) { $tree[$char] = []; } $tree = &$tree[$char]; } $last_size = $k + 1; $size = max($size, $last_size); } else { $last_size = 1; if (!isset($tree[$search_element])) { $tree[$search_element] = []; } $tree = &$tree[$search_element]; $size = max($last_size, $size); $this->index[$search_element] = true; } } if (null !== $i) { $tree[-1] = min(count($replace) - 1, $i); $tree[-2] = $last_size; $this->treeMaxLen = $size; } foreach ($replace as $rep) { if (!is_array($rep)) { $rep = [$rep]; } $this->replace[] = $rep; } for ($i = count($this->replace) - 1; $i >= 0; --$i) { $this->replace[$i] = $rep = $this->filter($this->replace[$i], $i); $this->repSize[$i] = count($rep); } } public function shouldBuffer($buffer) { $endOfBuffer = end($buffer); return isset($this->index[$endOfBuffer]); } public function filter($buffer, $minReplaces = -1) { if (0 == $this->treeMaxLen) { return $buffer; } $newBuffer = []; $buf_size = count($buffer); $last_size = 0; for ($i = 0; $i < $buf_size; ++$i) { $search_pos = $this->tree; $last_found = PHP_INT_MAX; for ($j = 0; $j <= $this->treeMaxLen; ++$j) { if (isset($buffer[$p = $i + $j]) && isset($search_pos[$buffer[$p]])) { $search_pos = $search_pos[$buffer[$p]]; if (isset($search_pos[-1]) && $search_pos[-1] < $last_found && $search_pos[-1] > $minReplaces) { $last_found = $search_pos[-1]; $last_size = $search_pos[-2]; } } elseif (PHP_INT_MAX !== $last_found) { $rep_size = $this->repSize[$last_found]; for ($j = 0; $j < $rep_size; ++$j) { $newBuffer[] = $this->replace[$last_found][$j]; } $i += $last_size - 1; if ($i >= $buf_size) { $newBuffer[] = $buffer[$i]; } continue 2; } else { break; } } $newBuffer[] = $buffer[$i]; } return $newBuffer; } } 