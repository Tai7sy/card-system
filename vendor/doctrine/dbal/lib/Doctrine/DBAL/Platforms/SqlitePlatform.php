<?php
 namespace Doctrine\DBAL\Platforms; use Doctrine\DBAL\DBALException; use Doctrine\DBAL\Schema\Column; use Doctrine\DBAL\Schema\TableDiff; use Doctrine\DBAL\Schema\Table; use Doctrine\DBAL\Schema\ForeignKeyConstraint; use Doctrine\DBAL\Schema\Index; use Doctrine\DBAL\Schema\Identifier; use Doctrine\DBAL\Schema\Constraint; class SqlitePlatform extends AbstractPlatform { public function getRegexpExpression() { return 'REGEXP'; } public function getGuidExpression() { return "HEX(RANDOMBLOB(4)) || '-' || HEX(RANDOMBLOB(2)) || '-4' || " . "SUBSTR(HEX(RANDOMBLOB(2)), 2) || '-' || " . "SUBSTR('89AB', 1 + (ABS(RANDOM()) % 4), 1) || " . "SUBSTR(HEX(RANDOMBLOB(2)), 2) || '-' || HEX(RANDOMBLOB(6))"; } public function getNowExpression($type = 'timestamp') { switch ($type) { case 'time': return 'time(\'now\')'; case 'date': return 'date(\'now\')'; case 'timestamp': default: return 'datetime(\'now\')'; } } public function getTrimExpression($str, $pos = self::TRIM_UNSPECIFIED, $char = false) { $trimChar = ($char != false) ? (', ' . $char) : ''; switch ($pos) { case self::TRIM_LEADING: $trimFn = 'LTRIM'; break; case self::TRIM_TRAILING: $trimFn = 'RTRIM'; break; default: $trimFn = 'TRIM'; } return $trimFn . '(' . $str . $trimChar . ')'; } public function getSubstringExpression($value, $position, $length = null) { if ($length !== null) { return 'SUBSTR(' . $value . ', ' . $position . ', ' . $length . ')'; } return 'SUBSTR(' . $value . ', ' . $position . ', LENGTH(' . $value . '))'; } public function getLocateExpression($str, $substr, $startPos = false) { if ($startPos == false) { return 'LOCATE('.$str.', '.$substr.')'; } return 'LOCATE('.$str.', '.$substr.', '.$startPos.')'; } protected function getDateArithmeticIntervalExpression($date, $operator, $interval, $unit) { switch ($unit) { case self::DATE_INTERVAL_UNIT_SECOND: case self::DATE_INTERVAL_UNIT_MINUTE: case self::DATE_INTERVAL_UNIT_HOUR: return "DATETIME(" . $date . ",'" . $operator . $interval . " " . $unit . "')"; default: switch ($unit) { case self::DATE_INTERVAL_UNIT_WEEK: $interval *= 7; $unit = self::DATE_INTERVAL_UNIT_DAY; break; case self::DATE_INTERVAL_UNIT_QUARTER: $interval *= 3; $unit = self::DATE_INTERVAL_UNIT_MONTH; break; } return "DATE(" . $date . ",'" . $operator . $interval . " " . $unit . "')"; } } public function getDateDiffExpression($date1, $date2) { return 'ROUND(JULIANDAY('.$date1 . ')-JULIANDAY('.$date2.'))'; } protected function _getTransactionIsolationLevelSQL($level) { switch ($level) { case \Doctrine\DBAL\Connection::TRANSACTION_READ_UNCOMMITTED: return 0; case \Doctrine\DBAL\Connection::TRANSACTION_READ_COMMITTED: case \Doctrine\DBAL\Connection::TRANSACTION_REPEATABLE_READ: case \Doctrine\DBAL\Connection::TRANSACTION_SERIALIZABLE: return 1; default: return parent::_getTransactionIsolationLevelSQL($level); } } public function getSetTransactionIsolationSQL($level) { return 'PRAGMA read_uncommitted = ' . $this->_getTransactionIsolationLevelSQL($level); } public function prefersIdentityColumns() { return true; } public function getBooleanTypeDeclarationSQL(array $field) { return 'BOOLEAN'; } public function getIntegerTypeDeclarationSQL(array $field) { return 'INTEGER' . $this->_getCommonIntegerTypeDeclarationSQL($field); } public function getBigIntTypeDeclarationSQL(array $field) { if ( ! empty($field['autoincrement'])) { return $this->getIntegerTypeDeclarationSQL($field); } return 'BIGINT' . $this->_getCommonIntegerTypeDeclarationSQL($field); } public function getTinyIntTypeDeclarationSql(array $field) { if ( ! empty($field['autoincrement'])) { return $this->getIntegerTypeDeclarationSQL($field); } return 'TINYINT' . $this->_getCommonIntegerTypeDeclarationSQL($field); } public function getSmallIntTypeDeclarationSQL(array $field) { if ( ! empty($field['autoincrement'])) { return $this->getIntegerTypeDeclarationSQL($field); } return 'SMALLINT' . $this->_getCommonIntegerTypeDeclarationSQL($field); } public function getMediumIntTypeDeclarationSql(array $field) { if ( ! empty($field['autoincrement'])) { return $this->getIntegerTypeDeclarationSQL($field); } return 'MEDIUMINT' . $this->_getCommonIntegerTypeDeclarationSQL($field); } public function getDateTimeTypeDeclarationSQL(array $fieldDeclaration) { return 'DATETIME'; } public function getDateTypeDeclarationSQL(array $fieldDeclaration) { return 'DATE'; } public function getTimeTypeDeclarationSQL(array $fieldDeclaration) { return 'TIME'; } protected function _getCommonIntegerTypeDeclarationSQL(array $columnDef) { if ( ! empty($columnDef['autoincrement'])) { return ''; } return ! empty($columnDef['unsigned']) ? ' UNSIGNED' : ''; } public function getForeignKeyDeclarationSQL(ForeignKeyConstraint $foreignKey) { return parent::getForeignKeyDeclarationSQL(new ForeignKeyConstraint( $foreignKey->getQuotedLocalColumns($this), str_replace('.', '__', $foreignKey->getQuotedForeignTableName($this)), $foreignKey->getQuotedForeignColumns($this), $foreignKey->getName(), $foreignKey->getOptions() )); } protected function _getCreateTableSQL($name, array $columns, array $options = array()) { $name = str_replace('.', '__', $name); $queryFields = $this->getColumnDeclarationListSQL($columns); if (isset($options['uniqueConstraints']) && ! empty($options['uniqueConstraints'])) { foreach ($options['uniqueConstraints'] as $name => $definition) { $queryFields .= ', ' . $this->getUniqueConstraintDeclarationSQL($name, $definition); } } if (isset($options['primary']) && ! empty($options['primary'])) { $keyColumns = array_unique(array_values($options['primary'])); $queryFields.= ', PRIMARY KEY('.implode(', ', $keyColumns).')'; } if (isset($options['foreignKeys'])) { foreach ($options['foreignKeys'] as $foreignKey) { $queryFields.= ', '.$this->getForeignKeyDeclarationSQL($foreignKey); } } $query[] = 'CREATE TABLE ' . $name . ' (' . $queryFields . ')'; if (isset($options['alter']) && true === $options['alter']) { return $query; } if (isset($options['indexes']) && ! empty($options['indexes'])) { foreach ($options['indexes'] as $indexDef) { $query[] = $this->getCreateIndexSQL($indexDef, $name); } } if (isset($options['unique']) && ! empty($options['unique'])) { foreach ($options['unique'] as $indexDef) { $query[] = $this->getCreateIndexSQL($indexDef, $name); } } return $query; } protected function getVarcharTypeDeclarationSQLSnippet($length, $fixed) { return $fixed ? ($length ? 'CHAR(' . $length . ')' : 'CHAR(255)') : ($length ? 'VARCHAR(' . $length . ')' : 'TEXT'); } protected function getBinaryTypeDeclarationSQLSnippet($length, $fixed) { return 'BLOB'; } public function getBinaryMaxLength() { return 0; } public function getBinaryDefaultLength() { return 0; } public function getClobTypeDeclarationSQL(array $field) { return 'CLOB'; } public function getListTableConstraintsSQL($table) { $table = str_replace('.', '__', $table); $table = $this->quoteStringLiteral($table); return "SELECT sql FROM sqlite_master WHERE type='index' AND tbl_name = $table AND sql NOT NULL ORDER BY name"; } public function getListTableColumnsSQL($table, $currentDatabase = null) { $table = str_replace('.', '__', $table); $table = $this->quoteStringLiteral($table); return "PRAGMA table_info($table)"; } public function getListTableIndexesSQL($table, $currentDatabase = null) { $table = str_replace('.', '__', $table); $table = $this->quoteStringLiteral($table); return "PRAGMA index_list($table)"; } public function getListTablesSQL() { return "SELECT name FROM sqlite_master WHERE type = 'table' AND name != 'sqlite_sequence' AND name != 'geometry_columns' AND name != 'spatial_ref_sys' " . "UNION ALL SELECT name FROM sqlite_temp_master " . "WHERE type = 'table' ORDER BY name"; } public function getListViewsSQL($database) { return "SELECT name, sql FROM sqlite_master WHERE type='view' AND sql NOT NULL"; } public function getCreateViewSQL($name, $sql) { return 'CREATE VIEW ' . $name . ' AS ' . $sql; } public function getDropViewSQL($name) { return 'DROP VIEW '. $name; } public function getAdvancedForeignKeyOptionsSQL(ForeignKeyConstraint $foreignKey) { $query = parent::getAdvancedForeignKeyOptionsSQL($foreignKey); $query .= (($foreignKey->hasOption('deferrable') && $foreignKey->getOption('deferrable') !== false) ? ' ' : ' NOT ') . 'DEFERRABLE'; $query .= ' INITIALLY ' . (($foreignKey->hasOption('deferred') && $foreignKey->getOption('deferred') !== false) ? 'DEFERRED' : 'IMMEDIATE'); return $query; } public function supportsIdentityColumns() { return true; } public function supportsColumnCollation() { return true; } public function getName() { return 'sqlite'; } public function getTruncateTableSQL($tableName, $cascade = false) { $tableIdentifier = new Identifier($tableName); $tableName = str_replace('.', '__', $tableIdentifier->getQuotedName($this)); return 'DELETE FROM ' . $tableName; } static public function udfSqrt($value) { return sqrt($value); } static public function udfMod($a, $b) { return ($a % $b); } static public function udfLocate($str, $substr, $offset = 0) { if ($offset > 0) { $offset -= 1; } $pos = strpos($str, $substr, $offset); if ($pos !== false) { return $pos + 1; } return 0; } public function getForUpdateSql() { return ''; } protected function initializeDoctrineTypeMappings() { $this->doctrineTypeMapping = array( 'boolean' => 'boolean', 'tinyint' => 'boolean', 'smallint' => 'smallint', 'mediumint' => 'integer', 'int' => 'integer', 'integer' => 'integer', 'serial' => 'integer', 'bigint' => 'bigint', 'bigserial' => 'bigint', 'clob' => 'text', 'tinytext' => 'text', 'mediumtext' => 'text', 'longtext' => 'text', 'text' => 'text', 'varchar' => 'string', 'longvarchar' => 'string', 'varchar2' => 'string', 'nvarchar' => 'string', 'image' => 'string', 'ntext' => 'string', 'char' => 'string', 'date' => 'date', 'datetime' => 'datetime', 'timestamp' => 'datetime', 'time' => 'time', 'float' => 'float', 'double' => 'float', 'double precision' => 'float', 'real' => 'float', 'decimal' => 'decimal', 'numeric' => 'decimal', 'blob' => 'blob', ); } protected function getReservedKeywordsClass() { return 'Doctrine\DBAL\Platforms\Keywords\SQLiteKeywords'; } protected function getPreAlterTableIndexForeignKeySQL(TableDiff $diff) { if ( ! $diff->fromTable instanceof Table) { throw new DBALException('Sqlite platform requires for alter table the table diff with reference to original table schema'); } $sql = array(); foreach ($diff->fromTable->getIndexes() as $index) { if ( ! $index->isPrimary()) { $sql[] = $this->getDropIndexSQL($index, $diff->name); } } return $sql; } protected function getPostAlterTableIndexForeignKeySQL(TableDiff $diff) { if ( ! $diff->fromTable instanceof Table) { throw new DBALException('Sqlite platform requires for alter table the table diff with reference to original table schema'); } $sql = array(); $tableName = $diff->newName ? $diff->getNewName(): $diff->getName($this); foreach ($this->getIndexesInAlteredTable($diff) as $index) { if ($index->isPrimary()) { continue; } $sql[] = $this->getCreateIndexSQL($index, $tableName->getQuotedName($this)); } return $sql; } protected function doModifyLimitQuery($query, $limit, $offset) { if (null === $limit && null !== $offset) { return $query . ' LIMIT -1 OFFSET ' . $offset; } return parent::doModifyLimitQuery($query, $limit, $offset); } public function getBlobTypeDeclarationSQL(array $field) { return 'BLOB'; } public function getTemporaryTableName($tableName) { $tableName = str_replace('.', '__', $tableName); return $tableName; } public function canEmulateSchemas() { return true; } public function supportsForeignKeyConstraints() { return false; } public function getCreatePrimaryKeySQL(Index $index, $table) { throw new DBALException('Sqlite platform does not support alter primary key.'); } public function getCreateForeignKeySQL(ForeignKeyConstraint $foreignKey, $table) { throw new DBALException('Sqlite platform does not support alter foreign key.'); } public function getDropForeignKeySQL($foreignKey, $table) { throw new DBALException('Sqlite platform does not support alter foreign key.'); } public function getCreateConstraintSQL(Constraint $constraint, $table) { throw new DBALException('Sqlite platform does not support alter constraint.'); } public function getCreateTableSQL(Table $table, $createFlags = null) { $createFlags = null === $createFlags ? self::CREATE_INDEXES | self::CREATE_FOREIGNKEYS : $createFlags; return parent::getCreateTableSQL($table, $createFlags); } public function getListTableForeignKeysSQL($table, $database = null) { $table = str_replace('.', '__', $table); $table = $this->quoteStringLiteral($table); return "PRAGMA foreign_key_list($table)"; } public function getAlterTableSQL(TableDiff $diff) { $sql = $this->getSimpleAlterTableSQL($diff); if (false !== $sql) { return $sql; } $fromTable = $diff->fromTable; if ( ! $fromTable instanceof Table) { throw new DBALException('Sqlite platform requires for alter table the table diff with reference to original table schema'); } $table = clone $fromTable; $columns = array(); $oldColumnNames = array(); $newColumnNames = array(); $columnSql = array(); foreach ($table->getColumns() as $columnName => $column) { $columnName = strtolower($columnName); $columns[$columnName] = $column; $oldColumnNames[$columnName] = $newColumnNames[$columnName] = $column->getQuotedName($this); } foreach ($diff->removedColumns as $columnName => $column) { if ($this->onSchemaAlterTableRemoveColumn($column, $diff, $columnSql)) { continue; } $columnName = strtolower($columnName); if (isset($columns[$columnName])) { unset($columns[$columnName]); unset($oldColumnNames[$columnName]); unset($newColumnNames[$columnName]); } } foreach ($diff->renamedColumns as $oldColumnName => $column) { if ($this->onSchemaAlterTableRenameColumn($oldColumnName, $column, $diff, $columnSql)) { continue; } $oldColumnName = strtolower($oldColumnName); if (isset($columns[$oldColumnName])) { unset($columns[$oldColumnName]); } $columns[strtolower($column->getName())] = $column; if (isset($newColumnNames[$oldColumnName])) { $newColumnNames[$oldColumnName] = $column->getQuotedName($this); } } foreach ($diff->changedColumns as $oldColumnName => $columnDiff) { if ($this->onSchemaAlterTableChangeColumn($columnDiff, $diff, $columnSql)) { continue; } if (isset($columns[$oldColumnName])) { unset($columns[$oldColumnName]); } $columns[strtolower($columnDiff->column->getName())] = $columnDiff->column; if (isset($newColumnNames[$oldColumnName])) { $newColumnNames[$oldColumnName] = $columnDiff->column->getQuotedName($this); } } foreach ($diff->addedColumns as $columnName => $column) { if ($this->onSchemaAlterTableAddColumn($column, $diff, $columnSql)) { continue; } $columns[strtolower($columnName)] = $column; } $sql = array(); $tableSql = array(); if ( ! $this->onSchemaAlterTable($diff, $tableSql)) { $dataTable = new Table('__temp__'.$table->getName()); $newTable = new Table($table->getQuotedName($this), $columns, $this->getPrimaryIndexInAlteredTable($diff), $this->getForeignKeysInAlteredTable($diff), 0, $table->getOptions()); $newTable->addOption('alter', true); $sql = $this->getPreAlterTableIndexForeignKeySQL($diff); $sql[] = sprintf('CREATE TEMPORARY TABLE %s AS SELECT %s FROM %s', $dataTable->getQuotedName($this), implode(', ', $oldColumnNames), $table->getQuotedName($this)); $sql[] = $this->getDropTableSQL($fromTable); $sql = array_merge($sql, $this->getCreateTableSQL($newTable)); $sql[] = sprintf('INSERT INTO %s (%s) SELECT %s FROM %s', $newTable->getQuotedName($this), implode(', ', $newColumnNames), implode(', ', $oldColumnNames), $dataTable->getQuotedName($this)); $sql[] = $this->getDropTableSQL($dataTable); if ($diff->newName && $diff->newName != $diff->name) { $renamedTable = $diff->getNewName(); $sql[] = 'ALTER TABLE '.$newTable->getQuotedName($this).' RENAME TO '.$renamedTable->getQuotedName($this); } $sql = array_merge($sql, $this->getPostAlterTableIndexForeignKeySQL($diff)); } return array_merge($sql, $tableSql, $columnSql); } private function getSimpleAlterTableSQL(TableDiff $diff) { foreach ($diff->changedColumns as $oldColumnName => $columnDiff) { if ( ! $columnDiff->fromColumn instanceof Column || ! $columnDiff->column instanceof Column || ! $columnDiff->column->getAutoincrement() || ! (string) $columnDiff->column->getType() === 'Integer' ) { continue; } if ( ! $columnDiff->hasChanged('type') && $columnDiff->hasChanged('unsigned')) { unset($diff->changedColumns[$oldColumnName]); continue; } $fromColumnType = (string) $columnDiff->fromColumn->getType(); if ($fromColumnType === 'SmallInt' || $fromColumnType === 'BigInt') { unset($diff->changedColumns[$oldColumnName]); } } if ( ! empty($diff->renamedColumns) || ! empty($diff->addedForeignKeys) || ! empty($diff->addedIndexes) || ! empty($diff->changedColumns) || ! empty($diff->changedForeignKeys) || ! empty($diff->changedIndexes) || ! empty($diff->removedColumns) || ! empty($diff->removedForeignKeys) || ! empty($diff->removedIndexes) || ! empty($diff->renamedIndexes) ) { return false; } $table = new Table($diff->name); $sql = array(); $tableSql = array(); $columnSql = array(); foreach ($diff->addedColumns as $column) { if ($this->onSchemaAlterTableAddColumn($column, $diff, $columnSql)) { continue; } $field = array_merge(array('unique' => null, 'autoincrement' => null, 'default' => null), $column->toArray()); $type = (string) $field['type']; switch (true) { case isset($field['columnDefinition']) || $field['autoincrement'] || $field['unique']: case $type == 'DateTime' && $field['default'] == $this->getCurrentTimestampSQL(): case $type == 'Date' && $field['default'] == $this->getCurrentDateSQL(): case $type == 'Time' && $field['default'] == $this->getCurrentTimeSQL(): return false; } $field['name'] = $column->getQuotedName($this); if (strtolower($field['type']) == 'string' && $field['length'] === null) { $field['length'] = 255; } $sql[] = 'ALTER TABLE '.$table->getQuotedName($this).' ADD COLUMN '.$this->getColumnDeclarationSQL($field['name'], $field); } if ( ! $this->onSchemaAlterTable($diff, $tableSql)) { if ($diff->newName !== false) { $newTable = new Identifier($diff->newName); $sql[] = 'ALTER TABLE '.$table->getQuotedName($this).' RENAME TO '.$newTable->getQuotedName($this); } } return array_merge($sql, $tableSql, $columnSql); } private function getColumnNamesInAlteredTable(TableDiff $diff) { $columns = array(); foreach ($diff->fromTable->getColumns() as $columnName => $column) { $columns[strtolower($columnName)] = $column->getName(); } foreach ($diff->removedColumns as $columnName => $column) { $columnName = strtolower($columnName); if (isset($columns[$columnName])) { unset($columns[$columnName]); } } foreach ($diff->renamedColumns as $oldColumnName => $column) { $columnName = $column->getName(); $columns[strtolower($oldColumnName)] = $columnName; $columns[strtolower($columnName)] = $columnName; } foreach ($diff->changedColumns as $oldColumnName => $columnDiff) { $columnName = $columnDiff->column->getName(); $columns[strtolower($oldColumnName)] = $columnName; $columns[strtolower($columnName)] = $columnName; } foreach ($diff->addedColumns as $columnName => $column) { $columns[strtolower($columnName)] = $columnName; } return $columns; } private function getIndexesInAlteredTable(TableDiff $diff) { $indexes = $diff->fromTable->getIndexes(); $columnNames = $this->getColumnNamesInAlteredTable($diff); foreach ($indexes as $key => $index) { foreach ($diff->renamedIndexes as $oldIndexName => $renamedIndex) { if (strtolower($key) === strtolower($oldIndexName)) { unset($indexes[$key]); } } $changed = false; $indexColumns = array(); foreach ($index->getColumns() as $columnName) { $normalizedColumnName = strtolower($columnName); if ( ! isset($columnNames[$normalizedColumnName])) { unset($indexes[$key]); continue 2; } else { $indexColumns[] = $columnNames[$normalizedColumnName]; if ($columnName !== $columnNames[$normalizedColumnName]) { $changed = true; } } } if ($changed) { $indexes[$key] = new Index($index->getName(), $indexColumns, $index->isUnique(), $index->isPrimary(), $index->getFlags()); } } foreach ($diff->removedIndexes as $index) { $indexName = strtolower($index->getName()); if (strlen($indexName) && isset($indexes[$indexName])) { unset($indexes[$indexName]); } } foreach (array_merge($diff->changedIndexes, $diff->addedIndexes, $diff->renamedIndexes) as $index) { $indexName = strtolower($index->getName()); if (strlen($indexName)) { $indexes[$indexName] = $index; } else { $indexes[] = $index; } } return $indexes; } private function getForeignKeysInAlteredTable(TableDiff $diff) { $foreignKeys = $diff->fromTable->getForeignKeys(); $columnNames = $this->getColumnNamesInAlteredTable($diff); foreach ($foreignKeys as $key => $constraint) { $changed = false; $localColumns = array(); foreach ($constraint->getLocalColumns() as $columnName) { $normalizedColumnName = strtolower($columnName); if ( ! isset($columnNames[$normalizedColumnName])) { unset($foreignKeys[$key]); continue 2; } else { $localColumns[] = $columnNames[$normalizedColumnName]; if ($columnName !== $columnNames[$normalizedColumnName]) { $changed = true; } } } if ($changed) { $foreignKeys[$key] = new ForeignKeyConstraint($localColumns, $constraint->getForeignTableName(), $constraint->getForeignColumns(), $constraint->getName(), $constraint->getOptions()); } } foreach ($diff->removedForeignKeys as $constraint) { $constraintName = strtolower($constraint->getName()); if (strlen($constraintName) && isset($foreignKeys[$constraintName])) { unset($foreignKeys[$constraintName]); } } foreach (array_merge($diff->changedForeignKeys, $diff->addedForeignKeys) as $constraint) { $constraintName = strtolower($constraint->getName()); if (strlen($constraintName)) { $foreignKeys[$constraintName] = $constraint; } else { $foreignKeys[] = $constraint; } } return $foreignKeys; } private function getPrimaryIndexInAlteredTable(TableDiff $diff) { $primaryIndex = array(); foreach ($this->getIndexesInAlteredTable($diff) as $index) { if ($index->isPrimary()) { $primaryIndex = array($index->getName() => $index); } } return $primaryIndex; } } 